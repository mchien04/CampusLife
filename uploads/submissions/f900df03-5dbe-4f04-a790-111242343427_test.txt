T√¥i th·∫•y v·∫•n ƒë·ªÅ! Logic auto-registration ƒë√£ ƒë∆∞·ª£c implement nh∆∞ng c√≥ th·ªÉ c√≥ v·∫•n ƒë·ªÅ v·ªõi vi·ªác ki·ªÉm tra tr√πng l·∫∑p ho·∫∑c c√°ch ho·∫°t ƒë·ªông. H√£y t√¥i ki·ªÉm tra v√† s·ª≠a:


[1 tool called]

T√¥i th·∫•y v·∫•n ƒë·ªÅ! Logic auto-registration ƒë√£ ƒë√∫ng nh∆∞ng c·∫ßn th√™m ki·ªÉm tra tr√πng l·∫∑p ƒë·ªÉ tr√°nh t·∫°o registration nhi·ªÅu l·∫ßn. H√£y t√¥i s·ª≠a:


[1 tool called]

B√¢y gi·ªù t√¥i c·∫ßn th√™m logic ƒë·ªÉ c·∫≠p nh·∫≠t activity c≈©ng trigger auto-registration n·∫øu c√≥ thay ƒë·ªïi flags:


[1 tool called]

B√¢y gi·ªù t√¥i c·∫ßn th√™m API ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i ƒëƒÉng k√Ω v√† ngƒÉn h·ªßy ƒëƒÉng k√Ω n·∫øu status l√† APPROVED:


[3 tools called]

B√¢y gi·ªù t√¥i c·∫ßn c·∫≠p nh·∫≠t logic h·ªßy ƒëƒÉng k√Ω ƒë·ªÉ ngƒÉn h·ªßy n·∫øu status l√† APPROVED:


[1 tool called]

T√¥i th·∫•y logic h·ªßy ƒëƒÉng k√Ω hi·ªán t·∫°i cho ph√©p h·ªßy c·∫£ APPROVED. T√¥i c·∫ßn s·ª≠a ƒë·ªÉ ngƒÉn h·ªßy n·∫øu status l√† APPROVED:


[1 tool called]

B√¢y gi·ªù t√¥i c·∫ßn ki·ªÉm tra linter errors:


[1 tool called]

T√¥i s·∫Ω s·ª≠a linter warning:


[2 tools called]

B√¢y gi·ªù t√¥i s·∫Ω t·∫°o m·ªôt test ƒë·ªÉ ki·ªÉm tra auto-registration:


[2 tools called]

Tuy·ªát v·ªùi! Code ƒë√£ compile th√†nh c√¥ng. B√¢y gi·ªù t√¥i s·∫Ω t√≥m t·∫Øt nh·ªØng g√¨ ƒë√£ ƒë∆∞·ª£c implement:

## **‚úÖ ƒê√É HO√ÄN TH√ÄNH AUTO-REGISTRATION CHO ACTIVITIES**

### **üîß C√ÅC THAY ƒê·ªîI CH√çNH:**

#### **1. üìù Logic Auto-Registration (ActivityServiceImpl.java):**
- **T·ª± ƒë·ªông ƒëƒÉng k√Ω khi t·∫°o activity m·ªõi** n·∫øu:
  - `isImportant = true` ‚Üí ƒêƒÉng k√Ω cho **T·∫§T C·∫¢** sinh vi√™n
  - `mandatoryForFacultyStudents = true` ‚Üí ƒêƒÉng k√Ω cho sinh vi√™n thu·ªôc **khoa t·ªï ch·ª©c**
- **T·ª± ƒë·ªông ƒëƒÉng k√Ω khi c·∫≠p nh·∫≠t activity** n·∫øu c√≥ thay ƒë·ªïi flags
- **Ki·ªÉm tra tr√πng l·∫∑p** ƒë·ªÉ tr√°nh ƒëƒÉng k√Ω nhi·ªÅu l·∫ßn
- **Tr·∫°ng th√°i APPROVED** cho auto-registration (kh√¥ng th·ªÉ h·ªßy)

#### **2. üö´ NgƒÉn H·ªßy ƒêƒÉng K√Ω APPROVED:**
- **C·∫≠p nh·∫≠t logic h·ªßy ƒëƒÉng k√Ω** trong `ActivityRegistrationServiceImpl.java`
- **Kh√¥ng cho ph√©p h·ªßy** n·∫øu status l√† `APPROVED`
- **Th√¥ng b√°o r√µ r√†ng** cho user

#### **3. üîç API Ki·ªÉm Tra Tr·∫°ng Th√°i ƒêƒÉng K√Ω:**
- **Endpoint m·ªõi:** `GET /api/activities/{activityId}/registration-status`
- **Tr·∫£ v·ªÅ th√¥ng tin:**
  - `isRegistered`: C√≥ ƒëƒÉng k√Ω ch∆∞a
  - `status`: Tr·∫°ng th√°i ƒëƒÉng k√Ω
  - `canCancel`: C√≥ th·ªÉ h·ªßy kh√¥ng
  - `registeredDate`: Ng√†y ƒëƒÉng k√Ω

### **üìã C√ÅCH HO·∫†T ƒê·ªòNG:**

#### **üéØ Khi T·∫°o Activity:**
```json
{
  "name": "S·ª± ki·ªán quan tr·ªçng",
  "isImportant": true,
  "mandatoryForFacultyStudents": true,
  "organizerIds": [1, 2]
}
```
‚Üí **T·ª± ƒë·ªông ƒëƒÉng k√Ω:**
- T·∫•t c·∫£ sinh vi√™n (v√¨ `isImportant = true`)
- Sinh vi√™n khoa 1, 2 (v√¨ `mandatoryForFacultyStudents = true`)
- Status: `APPROVED` (kh√¥ng th·ªÉ h·ªßy)

#### **üîÑ Khi C·∫≠p Nh·∫≠t Activity:**
- N·∫øu thay ƒë·ªïi `isImportant` ho·∫∑c `mandatoryForFacultyStudents`
- S·∫Ω t·ª± ƒë·ªông ƒëƒÉng k√Ω th√™m sinh vi√™n ph√π h·ª£p
- Ch·ªâ ƒëƒÉng k√Ω nh·ªØng sinh vi√™n ch∆∞a ƒëƒÉng k√Ω

#### **‚ùå Khi H·ªßy ƒêƒÉng K√Ω:**
- **PENDING** ‚Üí ‚úÖ C√≥ th·ªÉ h·ªßy
- **APPROVED** ‚Üí ‚ùå Kh√¥ng th·ªÉ h·ªßy (auto-registration)
- **CANCELLED** ‚Üí ‚ùå ƒê√£ h·ªßy r·ªìi

### **üåê API ENDPOINTS M·ªöI:**

#### **1. Ki·ªÉm tra tr·∫°ng th√°i ƒëƒÉng k√Ω:**
```http
GET /api/activities/{activityId}/registration-status
Authorization: Bearer <token>
```

**Response:**
```json
{
  "status": true,
  "message": "Registration status checked successfully",
  "body": {
    "activityId": 1,
    "studentId": 123,
    "isRegistered": true,
    "registrationId": 456,
    "status": "APPROVED",
    "registeredDate": "2024-01-15T10:30:00",
    "canCancel": false
  }
}
```

### **üîß LOGGING:**
- **Ghi log chi ti·∫øt** qu√° tr√¨nh auto-registration
- **Theo d√µi s·ªë l∆∞·ª£ng** sinh vi√™n ƒë∆∞·ª£c ƒëƒÉng k√Ω
- **B√°o l·ªói** n·∫øu c√≥ v·∫•n ƒë·ªÅ

### **‚ö†Ô∏è L∆ØU √ù QUAN TR·ªåNG:**
1. **Auto-registration ch·ªâ ch·∫°y khi t·∫°o/c·∫≠p nh·∫≠t activity**
2. **Status APPROVED = Kh√¥ng th·ªÉ h·ªßy** (b·∫£o v·ªá auto-registration)
3. **Ki·ªÉm tra tr√πng l·∫∑p** tr∆∞·ªõc khi t·∫°o registration m·ªõi
4. **Logging ƒë·∫ßy ƒë·ªß** ƒë·ªÉ debug v√† monitor

B√¢y gi·ªù khi b·∫°n t·∫°o ho·∫∑c c·∫≠p nh·∫≠t activity v·ªõi `isImportant = true` ho·∫∑c `mandatoryForFacultyStudents = true`, h·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông ƒëƒÉng k√Ω cho sinh vi√™n ph√π h·ª£p v·ªõi status `APPROVED` v√† kh√¥ng th·ªÉ h·ªßy ƒë∆∞·ª£c!

package vn.campuslife.service.impl;

import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import vn.campuslife.entity.Activity;
import vn.campuslife.entity.ActivityRegistration;
import vn.campuslife.entity.Department;
import vn.campuslife.entity.Student;
import vn.campuslife.enumeration.ScoreType;
import vn.campuslife.model.ActivityResponse;
import vn.campuslife.model.CreateActivityRequest;
import vn.campuslife.model.Response;
import vn.campuslife.repository.ActivityRegistrationRepository;
import vn.campuslife.repository.ActivityRepository;
import vn.campuslife.repository.DepartmentRepository;
import vn.campuslife.repository.StudentRepository;
import vn.campuslife.service.ActivityService;

import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ActivityServiceImpl implements ActivityService {

    private static final Logger logger = LoggerFactory.getLogger(ActivityServiceImpl.class);

    private final ActivityRepository activityRepository;
    private final ActivityRegistrationRepository activityRegistrationRepository;
    private final DepartmentRepository departmentRepository;
    private final StudentRepository studentRepository;

    @Override
    @Transactional
    public Response createActivity(CreateActivityRequest request) {
        try {

            String err = validateRequest(request);
            if (err != null)
                return new Response(false, err, null);

            Set<Department> organizers = resolveOrganizers(request.getOrganizerIds());

            Activity a = new Activity();
            applyRequestToEntity(request, a);
            a.setOrganizers(organizers);

            Activity saved = activityRepository.save(a);

            // Auto-register students based on flags
            autoRegisterStudents(saved);

            return new Response(true, "Activity created successfully", toResponse(saved));
        } catch (Exception e) {
            logger.error("Failed to create activity: {}", e.getMessage(), e);
            return new Response(false, "Failed to create activity due to server error", null);
        }
    }

    @Override
    public Response getAllActivities() {
        try {
            var list = activityRepository.findByIsDeletedFalseOrderByStartDateAsc();
            var data = list.stream().map(this::toResponse).toList();
            return new Response(true, "Activities retrieved successfully", data);
        } catch (Exception e) {
            logger.error("Failed to retrieve activities: {}", e.getMessage(), e);
            return new Response(false, "Failed to retrieve activities due to server error", null);
        }
    }

    @Override
    public Response getActivityById(Long id) {
        try {
            var opt = activityRepository.findByIdAndIsDeletedFalse(id);
            if (opt.isEmpty())
                return new Response(false, "Activity not found", null);
            return new Response(true, "Activity retrieved successfully", toResponse(opt.get()));
        } catch (Exception e) {
            logger.error("Failed to retrieve activity {}: {}", id, e.getMessage(), e);
            return new Response(false, "Failed to retrieve activity due to server error", null);
        }
    }

    @Override
    @Transactional
    public Response updateActivity(Long id, CreateActivityRequest request) {
        try {
            var opt = activityRepository.findByIdAndIsDeletedFalse(id);
            if (opt.isEmpty())
                return new Response(false, "Activity not found", null);

            String err = validateRequest(request);
            if (err != null)
                return new Response(false, err, null);

            Activity a = opt.get();

            applyRequestToEntity(request, a);

            Set<Department> organizers = resolveOrganizers(request.getOrganizerIds());
            a.getOrganizers().clear();
            a.getOrganizers().addAll(organizers);

            Activity saved = activityRepository.save(a);

            // Auto-register students if flags changed
            autoRegisterStudents(saved);

            return new Response(true, "Activity updated successfully", toResponse(saved));
        } catch (Exception e) {
            logger.error("Failed to update activity {}: {}", id, e.getMessage(), e);
            return new Response(false, "Failed to update activity due to server error", null);
        }
    }

    @Override
    @Transactional
    public Response deleteActivity(Long id) {
        try {
            var opt = activityRepository.findByIdAndIsDeletedFalse(id);
            if (opt.isEmpty())
                return new Response(false, "Activity not found", null);

            Activity a = opt.get();
            a.setDeleted(true);
            activityRepository.save(a);
            return new Response(true, "Activity deleted successfully", null);
        } catch (Exception e) {
            logger.error("Failed to delete activity {}: {}", id, e.getMessage(), e);
            return new Response(false, "Failed to delete activity due to server error", null);
        }
    }

    @Override
    public List<Activity> getActivitiesByScoreType(ScoreType scoreType) {
        return activityRepository.findByScoreTypeAndIsDeletedFalseOrderByStartDateAsc(scoreType);
    }

    @Override
    public List<Activity> getActivitiesByMonth(LocalDate start, LocalDate end) {
        return activityRepository.findInMonth(start, end);
    }

    @Override
    public List<Activity> getActivitiesForDepartment(Long departmentId) {
        return activityRepository.findForDepartment(departmentId);
    }

    @Override
    public List<Activity> listForCurrentUser(String username) {
        Long deptId = studentRepository.findDepartmentIdByUsername(username);
        if (deptId == null)
            return Collections.emptyList();
        return activityRepository.findForDepartment(deptId);
    }

    @Override
    public Response checkRequiresSubmission(Long activityId) {
        try {
            Optional<Activity> activityOpt = activityRepository.findByIdAndIsDeletedFalse(activityId);
            if (activityOpt.isEmpty()) {
                return new Response(false, "Activity not found", null);
            }

            Activity activity = activityOpt.get();
            Map<String, Object> result = new HashMap<>();
            result.put("activityId", activity.getId());
            result.put("activityName", activity.getName());
            result.put("requiresSubmission", activity.isRequiresSubmission());
            result.put("isImportant", activity.isImportant());
            result.put("mandatoryForFacultyStudents", activity.isMandatoryForFacultyStudents());
            result.put("maxPoints", activity.getMaxPoints());
            result.put("scoreType", activity.getScoreType());

            return new Response(true, "Submission requirement checked successfully", result);
        } catch (Exception e) {
            logger.error("Failed to check submission requirement for activity {}: {}", activityId, e.getMessage(), e);
            return new Response(false, "Failed to check submission requirement", null);
        }
    }

    @Override
    public Response checkRegistrationStatus(Long activityId, String username) {
        try {
            // Get student by username
            Optional<Student> studentOpt = studentRepository.findByUserUsernameAndIsDeletedFalse(username);
            if (studentOpt.isEmpty()) {
                return new Response(false, "Student not found", null);
            }

            // Check if activity exists
            Optional<Activity> activityOpt = activityRepository.findByIdAndIsDeletedFalse(activityId);
            if (activityOpt.isEmpty()) {
                return new Response(false, "Activity not found", null);
            }

            // Check registration status
            Optional<ActivityRegistration> registrationOpt = activityRegistrationRepository
                    .findByActivityIdAndStudentId(activityId, studentOpt.get().getId());

            Map<String, Object> result = new HashMap<>();
            result.put("activityId", activityId);
            result.put("studentId", studentOpt.get().getId());
            result.put("isRegistered", registrationOpt.isPresent());

            if (registrationOpt.isPresent()) {
                ActivityRegistration registration = registrationOpt.get();
                result.put("registrationId", registration.getId());
                result.put("status", registration.getStatus());
                result.put("registeredDate", registration.getRegisteredDate());
                result.put("canCancel",
                        !registration.getStatus().equals(vn.campuslife.enumeration.RegistrationStatus.APPROVED));
            }

            return new Response(true, "Registration status checked successfully", result);
        } catch (Exception e) {
            logger.error("Failed to check registration status for activity {} and user {}: {}", activityId, username,
                    e.getMessage(), e);
            return new Response(false, "Failed to check registration status", null);
        }
    }

    private String validateRequest(CreateActivityRequest r) {
        if (r.getName() == null || r.getName().isBlank())
            return "Activity name is required";
        if (r.getType() == null)
            return "Activity type is required";
        if (r.getScoreType() == null)
            return "Score type is required";
        if (r.getStartDate() == null || r.getEndDate() == null)
            return "Start date and end date are required";
        if (r.getStartDate().isAfter(r.getEndDate()))
            return "Start date must be before end date";
        if (r.getLocation() == null || r.getLocation().isBlank())
            return "Location is required";
        if (r.getOrganizerIds() == null || r.getOrganizerIds().isEmpty())
            return "Organizer ids are required";
        return null;
    }

    private void applyRequestToEntity(CreateActivityRequest req, Activity a) {
        a.setName(req.getName());
        a.setType(req.getType());
        a.setScoreType(req.getScoreType());
        a.setDescription(req.getDescription());
        a.setStartDate(req.getStartDate());
        a.setEndDate(req.getEndDate());

        a.setRequiresSubmission(Boolean.TRUE.equals(req.getRequiresSubmission()));
        a.setMaxPoints(req.getMaxPoints());

        a.setRegistrationStartDate(req.getRegistrationStartDate());
        a.setRegistrationDeadline(req.getRegistrationDeadline());

        a.setShareLink(req.getShareLink());
        a.setImportant(Boolean.TRUE.equals(req.getIsImportant()));
        a.setBannerUrl(req.getBannerUrl());
        a.setLocation(req.getLocation());

        a.setTicketQuantity(req.getTicketQuantity());
        a.setBenefits(req.getBenefits());
        a.setRequirements(req.getRequirements());
        a.setContactInfo(req.getContactInfo());
        a.setMandatoryForFacultyStudents(Boolean.TRUE.equals(req.getMandatoryForFacultyStudents()));
        a.setPenaltyPointsIncomplete(req.getPenaltyPointsIncomplete());
    }

    private Set<Department> resolveOrganizers(List<Long> organizerIds) {
        if (organizerIds == null || organizerIds.isEmpty())
            return new LinkedHashSet<>();
        var deps = departmentRepository.findAllById(organizerIds);
        var found = deps.stream().map(Department::getId).collect(Collectors.toSet());
        var missing = organizerIds.stream().filter(id -> !found.contains(id)).toList();
        if (!missing.isEmpty()) {
            throw new IllegalArgumentException("Department ids not found: " + missing);
        }
        return new LinkedHashSet<>(deps);
    }

    private ActivityResponse toResponse(Activity a) {
        ActivityResponse dto = new ActivityResponse();
        dto.setId(a.getId());
        dto.setName(a.getName());
        dto.setType(a.getType());
        dto.setScoreType(a.getScoreType());
        dto.setDescription(a.getDescription());
        dto.setStartDate(a.getStartDate());
        dto.setEndDate(a.getEndDate());

        dto.setRequiresSubmission(a.isRequiresSubmission());
        dto.setMaxPoints(a.getMaxPoints());

        dto.setRegistrationStartDate(a.getRegistrationStartDate());
        dto.setRegistrationDeadline(a.getRegistrationDeadline());

        dto.setShareLink(a.getShareLink());
        dto.setImportant(a.isImportant());
        dto.setBannerUrl(a.getBannerUrl());
        dto.setLocation(a.getLocation());

        dto.setTicketQuantity(a.getTicketQuantity());
        dto.setBenefits(a.getBenefits());
        dto.setRequirements(a.getRequirements());
        dto.setContactInfo(a.getContactInfo());
        dto.setMandatoryForFacultyStudents(a.isMandatoryForFacultyStudents());
        dto.setPenaltyPointsIncomplete(a.getPenaltyPointsIncomplete());
        dto.setOrganizerIds(a.getOrganizers() == null ? List.of()
                : a.getOrganizers().stream().map(Department::getId).toList());

        dto.setCreatedAt(a.getCreatedAt());
        dto.setUpdatedAt(a.getUpdatedAt());
        dto.setCreatedBy(a.getCreatedBy());
        dto.setLastModifiedBy(a.getLastModifiedBy());
        return dto;
    }

    /**
     * T·ª± ƒë·ªông ƒëƒÉng k√Ω sinh vi√™n cho activity d·ª±a tr√™n c√°c flag
     */
    private void autoRegisterStudents(Activity activity) {
        try {
            List<Student> studentsToRegister = new ArrayList<>();

            // N·∫øu isImportant = true: ƒëƒÉng k√Ω cho t·∫•t c·∫£ sinh vi√™n
            if (activity.isImportant()) {
                List<Student> allStudents = studentRepository.findAll().stream()
                        .filter(student -> !student.isDeleted())
                        .collect(Collectors.toList());
                studentsToRegister.addAll(allStudents);
                logger.info("Auto-registering {} students for important activity: {}", allStudents.size(),
                        activity.getName());
            }

            // N·∫øu mandatoryForFacultyStudents = true: ƒëƒÉng k√Ω cho sinh vi√™n thu·ªôc khoa t·ªï
            // ch·ª©c
            if (activity.isMandatoryForFacultyStudents() && !activity.getOrganizers().isEmpty()) {
                List<Long> departmentIds = activity.getOrganizers().stream()
                        .map(Department::getId)
                        .collect(Collectors.toList());

                List<Student> facultyStudents = studentRepository.findByDepartmentIdInAndIsDeletedFalse(departmentIds);
                studentsToRegister.addAll(facultyStudents);
                logger.info("Auto-registering {} faculty students for mandatory activity: {}", facultyStudents.size(),
                        activity.getName());
            }

            // T·∫°o registrations cho c√°c sinh vi√™n (ch·ªâ nh·ªØng sinh vi√™n ch∆∞a ƒëƒÉng k√Ω)
            if (!studentsToRegister.isEmpty()) {
                List<ActivityRegistration> registrations = studentsToRegister.stream()
                        .distinct() // Remove duplicates
                        .filter(student -> !activityRegistrationRepository
                                .existsByActivityIdAndStudentId(activity.getId(), student.getId()))
                        .map(student -> {
                            ActivityRegistration registration = new ActivityRegistration();
                            registration.setActivity(activity);
                            registration.setStudent(student);
                            registration.setStatus(vn.campuslife.enumeration.RegistrationStatus.APPROVED);
                            registration.setRegisteredDate(java.time.LocalDateTime.now());
                            return registration;
                        })
                        .collect(Collectors.toList());

                if (!registrations.isEmpty()) {
                    activityRegistrationRepository.saveAll(registrations);
                    logger.info("Successfully auto-registered {} students for activity: {}", registrations.size(),
                            activity.getName());
                } else {
                    logger.info("All students already registered for activity: {}", activity.getName());
                }
            }
        } catch (Exception e) {
            logger.error("Failed to auto-register students for activity {}: {}", activity.getId(), e.getMessage(), e);
        }
    }
}
package vn.campuslife.controller;

import vn.campuslife.entity.Activity;
import vn.campuslife.enumeration.ScoreType;
import vn.campuslife.model.CreateActivityRequest;
import vn.campuslife.model.Response;
import vn.campuslife.service.ActivityService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.YearMonth;
import java.util.List;

@RestController
@RequestMapping("/api/activities")
public class ActivityController {

    private static final Logger logger = LoggerFactory.getLogger(ActivityController.class);

    private final ActivityService activityService;

    public ActivityController(ActivityService activityService) {
        this.activityService = activityService;
    }

    @PostMapping
    public ResponseEntity<Response> createActivity(@RequestBody CreateActivityRequest request) {
        try {
            logger.info("=== CREATE ACTIVITY REQUEST ===");
            logger.info("Name: {}", request.getName());
            logger.info("Type: {}", request.getType());
            logger.info("ScoreType: {}", request.getScoreType());
            logger.info("BannerUrl: {}", request.getBannerUrl());
            logger.info("===============================");

            Response response = activityService.createActivity(request);
            return response.isStatus()
                    ? ResponseEntity.ok(response)
                    : ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            logger.error("Error creating activity: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError()
                    .body(new Response(false, "Server error occurred", null));
        }
    }

    @GetMapping
    public ResponseEntity<Response> getAllActivities() {
        try {
            Response response = activityService.getAllActivities();
            return response.isStatus()
                    ? ResponseEntity.ok(response)
                    : ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            logger.error("Error retrieving activities: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError()
                    .body(new Response(false, "Server error occurred", null));
        }
    }

    @GetMapping("/{id}")
    public ResponseEntity<Response> getActivityById(@PathVariable Long id) {
        try {
            Response response = activityService.getActivityById(id);
            return response.isStatus()
                    ? ResponseEntity.ok(response)
                    : ResponseEntity.notFound().build();
        } catch (Exception e) {
            logger.error("Error retrieving activity with id {}: {}", id, e.getMessage(), e);
            return ResponseEntity.internalServerError()
                    .body(new Response(false, "Server error occurred", null));
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<Response> updateActivity(@PathVariable Long id,
            @RequestBody CreateActivityRequest request) {
        try {
            Response response = activityService.updateActivity(id, request);
            return response.isStatus()
                    ? ResponseEntity.ok(response)
                    : ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            logger.error("Error updating activity with id {}: {}", id, e.getMessage(), e);
            return ResponseEntity.internalServerError()
                    .body(new Response(false, "Server error occurred", null));
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Response> deleteActivity(@PathVariable Long id) {
        try {
            Response response = activityService.deleteActivity(id);
            return response.isStatus()
                    ? ResponseEntity.ok(response)
                    : ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            logger.error("Error deleting activity with id {}: {}", id, e.getMessage(), e);
            return ResponseEntity.internalServerError()
                    .body(new Response(false, "Server error occurred", null));
        }
    }

    @GetMapping("/score-type/{scoreType}")
    public ResponseEntity<List<Activity>> getByScoreType(@PathVariable ScoreType scoreType) {
        return ResponseEntity.ok(activityService.getActivitiesByScoreType(scoreType));
    }

    @GetMapping("/month")
    public List<Activity> getByMonth(@RequestParam(required = false) Integer year,
            @RequestParam(required = false) Integer month) {
        YearMonth ym = (year == null || month == null) ? YearMonth.now() : YearMonth.of(year, month);
        LocalDate start = ym.atDay(1);
        LocalDate end = ym.plusMonths(1).atDay(1);
        return activityService.getActivitiesByMonth(start, end);
    }

    @GetMapping("/department/{deptId}")
    public List<Activity> byDepartment(@PathVariable Long deptId) {
        return activityService.getActivitiesForDepartment(deptId);
    }

    @GetMapping("/my")
    public List<Activity> myActivities(org.springframework.security.core.Authentication auth) {
        String username = (auth != null) ? auth.getName() : null;
        if (username == null)
            return List.of();
        return activityService.listForCurrentUser(username);
    }

    /**
     * Ki·ªÉm tra activity c√≥ y√™u c·∫ßu n·ªôp b√†i kh√¥ng
     */
    @GetMapping("/{activityId}/requires-submission")
    public ResponseEntity<Response> checkRequiresSubmission(@PathVariable Long activityId) {
        try {
            Response response = activityService.checkRequiresSubmission(activityId);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            logger.error("Error checking submission requirement for activity {}: {}", activityId, e.getMessage(), e);
            return ResponseEntity.internalServerError()
                    .body(new Response(false, "Server error occurred", null));
        }
    }

    /**
     * Ki·ªÉm tra tr·∫°ng th√°i ƒëƒÉng k√Ω c·ªßa student cho activity
     */
    @GetMapping("/{activityId}/registration-status")
    public ResponseEntity<Response> checkRegistrationStatus(@PathVariable Long activityId,
            org.springframework.security.core.Authentication auth) {
        try {
            String username = (auth != null) ? auth.getName() : null;
            if (username == null) {
                return ResponseEntity.badRequest()
                        .body(new Response(false, "Authentication required", null));
            }

            Response response = activityService.checkRegistrationStatus(activityId, username);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            logger.error("Error checking registration status for activity {}: {}", activityId, e.getMessage(), e);
            return ResponseEntity.internalServerError()
                    .body(new Response(false, "Server error occurred", null));
        }
    }
}
package vn.campuslife.service.impl;

import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import vn.campuslife.entity.*;
import vn.campuslife.enumeration.RegistrationStatus;
import vn.campuslife.model.*;
import vn.campuslife.repository.*;
import vn.campuslife.service.ActivityRegistrationService;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ActivityRegistrationServiceImpl implements ActivityRegistrationService {

    private static final Logger logger = LoggerFactory.getLogger(ActivityRegistrationServiceImpl.class);

    private final ActivityRegistrationRepository registrationRepository;
    private final ActivityParticipationRepository participationRepository;
    private final ActivityRepository activityRepository;
    private final StudentRepository studentRepository;

    @Override
    @Transactional
    public Response registerForActivity(ActivityRegistrationRequest request, Long studentId) {
        try {
            // Validate activity exists and not deleted
            Optional<Activity> activityOpt = activityRepository.findByIdAndIsDeletedFalse(request.getActivityId());
            if (activityOpt.isEmpty()) {
                return new Response(false, "Activity not found", null);
            }

            Activity activity = activityOpt.get();

            // Validate student exists
            Optional<Student> studentOpt = studentRepository.findByIdAndIsDeletedFalse(studentId);
            if (studentOpt.isEmpty()) {
                return new Response(false, "Student not found", null);
            }

            Student student = studentOpt.get();

            // Check if already registered
            if (registrationRepository.existsByActivityIdAndStudentId(request.getActivityId(), studentId)) {
                return new Response(false, "Already registered for this activity", null);
            }

            // Check registration deadline
            if (activity.getRegistrationDeadline() != null &&
                    LocalDateTime.now().isAfter(activity.getRegistrationDeadline().atStartOfDay())) {
                return new Response(false, "Registration deadline has passed", null);
            }

            // Check if registration is open
            if (activity.getRegistrationStartDate() != null &&
                    LocalDateTime.now().isBefore(activity.getRegistrationStartDate().atStartOfDay())) {
                return new Response(false, "Registration is not yet open", null);
            }

            // Check ticket quantity
            if (activity.getTicketQuantity() != null) {
                Long currentRegistrations = registrationRepository.countByActivityIdAndStatus(
                        request.getActivityId(), RegistrationStatus.APPROVED);
                if (currentRegistrations >= activity.getTicketQuantity()) {
                    return new Response(false, "Activity is full", null);
                }
            }

            // Create registration
            ActivityRegistration registration = new ActivityRegistration();
            registration.setActivity(activity);
            registration.setStudent(student);
            registration.setRegisteredDate(LocalDateTime.now());
            registration.setStatus(RegistrationStatus.PENDING);
            registration.setFeedback(request.getFeedback());

            ActivityRegistration savedRegistration = registrationRepository.save(registration);
            ActivityRegistrationResponse response = toRegistrationResponse(savedRegistration);

            return new Response(true, "Successfully registered for activity", response);
        } catch (Exception e) {
            logger.error("Failed to register for activity: {}", e.getMessage(), e);
            return new Response(false, "Failed to register due to server error", null);
        }
    }

    @Override
    @Transactional
    public Response cancelRegistration(Long activityId, Long studentId) {
        try {
            Optional<ActivityRegistration> registrationOpt = registrationRepository
                    .findByActivityIdAndStudentId(activityId, studentId);

            if (registrationOpt.isEmpty()) {
                return new Response(false, "Registration not found", null);
            }

            ActivityRegistration registration = registrationOpt.get();

            // Check if can cancel (only PENDING can be cancelled, APPROVED cannot be
            // cancelled)
            if (registration.getStatus() == RegistrationStatus.CANCELLED) {
                return new Response(false, "Registration already cancelled", null);
            }

            if (registration.getStatus() == RegistrationStatus.APPROVED) {
                return new Response(false,
                        "Cannot cancel approved registration. This is an auto-approved registration.", null);
            }

            registration.setStatus(RegistrationStatus.CANCELLED);
            registrationRepository.save(registration);

            return new Response(true, "Registration cancelled successfully", null);
        } catch (Exception e) {
            logger.error("Failed to cancel registration: {}", e.getMessage(), e);
            return new Response(false, "Failed to cancel registration due to server error", null);
        }
    }

    @Override
    public Response getStudentRegistrations(Long studentId) {
        try {
            List<ActivityRegistration> registrations = registrationRepository
                    .findByStudentIdAndStudentIsDeletedFalse(studentId);

            List<ActivityRegistrationResponse> responses = registrations.stream()
                    .map(this::toRegistrationResponse)
                    .collect(Collectors.toList());

            return new Response(true, "Student registrations retrieved successfully", responses);
        } catch (Exception e) {
            logger.error("Failed to retrieve student registrations: {}", e.getMessage(), e);
            return new Response(false, "Failed to retrieve registrations due to server error", null);
        }
    }

    @Override
    public Response getActivityRegistrations(Long activityId) {
        try {
            List<ActivityRegistration> registrations = registrationRepository
                    .findByActivityIdAndActivityIsDeletedFalse(activityId);

            List<ActivityRegistrationResponse> responses = registrations.stream()
                    .map(this::toRegistrationResponse)
                    .collect(Collectors.toList());

            return new Response(true, "Activity registrations retrieved successfully", responses);
        } catch (Exception e) {
            logger.error("Failed to retrieve activity registrations: {}", e.getMessage(), e);
            return new Response(false, "Failed to retrieve registrations due to server error", null);
        }
    }

    @Override
    @Transactional
    public Response updateRegistrationStatus(Long registrationId, String status) {
        try {
            Optional<ActivityRegistration> registrationOpt = registrationRepository.findById(registrationId);
            if (registrationOpt.isEmpty()) {
                return new Response(false, "Registration not found", null);
            }

            ActivityRegistration registration = registrationOpt.get();
            RegistrationStatus newStatus = RegistrationStatus.valueOf(status.toUpperCase());
            registration.setStatus(newStatus);

            ActivityRegistration savedRegistration = registrationRepository.save(registration);
            ActivityRegistrationResponse response = toRegistrationResponse(savedRegistration);

            return new Response(true, "Registration status updated successfully", response);
        } catch (IllegalArgumentException e) {
            return new Response(false, "Invalid status: " + status, null);
        } catch (Exception e) {
            logger.error("Failed to update registration status: {}", e.getMessage(), e);
            return new Response(false, "Failed to update status due to server error", null);
        }
    }

    @Override
    public Response getRegistrationById(Long registrationId) {
        try {
            Optional<ActivityRegistration> registrationOpt = registrationRepository.findById(registrationId);
            if (registrationOpt.isEmpty()) {
                return new Response(false, "Registration not found", null);
            }

            ActivityRegistrationResponse response = toRegistrationResponse(registrationOpt.get());
            return new Response(true, "Registration retrieved successfully", response);
        } catch (Exception e) {
            logger.error("Failed to retrieve registration: {}", e.getMessage(), e);
            return new Response(false, "Failed to retrieve registration due to server error", null);
        }
    }

    @Override
    @Transactional
    public Response recordParticipation(ActivityParticipationRequest request, Long studentId) {
        try {
            // Validate activity exists
            Optional<Activity> activityOpt = activityRepository.findByIdAndIsDeletedFalse(request.getActivityId());
            if (activityOpt.isEmpty()) {
                return new Response(false, "Activity not found", null);
            }

            // Validate student exists
            Optional<Student> studentOpt = studentRepository.findByIdAndIsDeletedFalse(studentId);
            if (studentOpt.isEmpty()) {
                return new Response(false, "Student not found", null);
            }

            // Check if student is registered and approved
            Optional<ActivityRegistration> registrationOpt = registrationRepository
                    .findByActivityIdAndStudentId(request.getActivityId(), studentId);

            if (registrationOpt.isEmpty() || registrationOpt.get().getStatus() != RegistrationStatus.APPROVED) {
                return new Response(false, "Student is not approved for this activity", null);
            }

            // Create participation record
            ActivityParticipation participation = new ActivityParticipation();
            participation.setActivity(activityOpt.get());
            participation.setStudent(studentOpt.get());
            participation.setParticipationType(request.getParticipationType());
            participation.setPointsEarned(request.getPointsEarned());
            participation.setDate(LocalDateTime.now());

            ActivityParticipation savedParticipation = participationRepository.save(participation);
            ActivityParticipationResponse response = toParticipationResponse(savedParticipation);

            return new Response(true, "Participation recorded successfully", response);
        } catch (Exception e) {
            logger.error("Failed to record participation: {}", e.getMessage(), e);
            return new Response(false, "Failed to record participation due to server error", null);
        }
    }

    @Override
    public Response getStudentParticipations(Long studentId) {
        try {
            List<ActivityParticipation> participations = participationRepository
                    .findByStudentIdAndActivityIsDeletedFalse(studentId);

            List<ActivityParticipationResponse> responses = participations.stream()
                    .map(this::toParticipationResponse)
                    .collect(Collectors.toList());

            return new Response(true, "Student participations retrieved successfully", responses);
        } catch (Exception e) {
            logger.error("Failed to retrieve student participations: {}", e.getMessage(), e);
            return new Response(false, "Failed to retrieve participations due to server error", null);
        }
    }

    @Override
    public Response getActivityParticipations(Long activityId) {
        try {
            List<ActivityParticipation> participations = participationRepository
                    .findByActivityIdAndActivityIsDeletedFalse(activityId);

            List<ActivityParticipationResponse> responses = participations.stream()
                    .map(this::toParticipationResponse)
                    .collect(Collectors.toList());

            return new Response(true, "Activity participations retrieved successfully", responses);
        } catch (Exception e) {
            logger.error("Failed to retrieve activity participations: {}", e.getMessage(), e);
            return new Response(false, "Failed to retrieve participations due to server error", null);
        }
    }

    @Override
    public Response checkRegistrationStatus(Long activityId, Long studentId) {
        try {
            Optional<ActivityRegistration> registrationOpt = registrationRepository
                    .findByActivityIdAndStudentId(activityId, studentId);

            if (registrationOpt.isEmpty()) {
                return new Response(true, "Not registered", null);
            }

            ActivityRegistrationResponse response = toRegistrationResponse(registrationOpt.get());
            return new Response(true, "Registration status retrieved", response);
        } catch (Exception e) {
            logger.error("Failed to check registration status: {}", e.getMessage(), e);
            return new Response(false, "Failed to check status due to server error", null);
        }
    }

    private ActivityRegistrationResponse toRegistrationResponse(ActivityRegistration registration) {
        ActivityRegistrationResponse response = new ActivityRegistrationResponse();
        response.setId(registration.getId());
        response.setActivityId(registration.getActivity().getId());
        response.setActivityName(registration.getActivity().getName());
        response.setActivityDescription(registration.getActivity().getDescription());
        response.setActivityStartDate(registration.getActivity().getStartDate());
        response.setActivityEndDate(registration.getActivity().getEndDate());
        response.setActivityLocation(registration.getActivity().getLocation());
        response.setStudentId(registration.getStudent().getId());
        response.setStudentName(registration.getStudent().getFullName());
        response.setStudentCode(registration.getStudent().getStudentCode());
        response.setStatus(registration.getStatus());
        response.setFeedback(registration.getFeedback());
        response.setRegisteredDate(registration.getRegisteredDate());
        response.setCreatedAt(registration.getCreatedAt());
        return response;
    }

    private ActivityParticipationResponse toParticipationResponse(ActivityParticipation participation) {
        ActivityParticipationResponse response = new ActivityParticipationResponse();
        response.setId(participation.getId());
        response.setActivityId(participation.getActivity().getId());
        response.setActivityName(participation.getActivity().getName());
        response.setStudentId(participation.getStudent().getId());
        response.setStudentName(participation.getStudent().getFullName());
        response.setStudentCode(participation.getStudent().getStudentCode());
        response.setParticipationType(participation.getParticipationType());
        response.setPointsEarned(participation.getPointsEarned());
        response.setDate(participation.getDate());
        return response;
    }
}
